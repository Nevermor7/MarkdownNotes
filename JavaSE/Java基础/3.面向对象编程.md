# OOP主线一：类和类的成员

## 属性

属性 = 成员变量 = field = 域、字段

### 成员变量 （非static）VS 局部变量

1. 相同点

   1. 定义的格式：数据类型  变量名  =  变量值
   2. 先声明，后使用。
   3. 都有其对应的作用域。

2. 不同点

   1. 在类中声明的位置不同

      属性：直接定义在类的一对{}内。

      局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内的变量。

   2. 权限修饰符的不同

      属性：可以在声明属性时指明其权限，常用的权限修饰符：private、public、缺省、protected。

      局部变量：不可以使用权限修饰符。

   3. 默认初始化值不同

      属性：根据类型都有默认初始化值。

      ​		整型：0

      ​		浮点型：0.0

      ​		字符型：\u0000

      ​		布尔型：false

      ​		引用数据类型：null

      局部变量：没有默认初始化值，所以调用局部变量之前必须先显式赋值。

      ​		特别的：形参在调用时赋值。

   4. 在内存中加载的位置不同

      属性：加载到堆空间中

      局部变量：加载到栈空间

### 属性赋值的先后顺序

①默认初始化

②显式初始化 / ⑤ 在代码块中赋值

③构造器初始化

④通过"对象.方法" 或 "对象.属性" 赋值

执行顺序：①	-	②  /  ⑤	-	③	-	④

```java
public class UserTest {
    public static void main(String[] args) {
        User u = new User();
        System.out.println(u.age); // 1		说明显式初始化在默认初始化之后
        User u1 = new User(2);
        System.out.println(u1.age); // 2	说明构造器初始化在显式初始化之后
        u1.setAge(3);
        System.out.println(u1.age); // 3	说明setter方法赋值在构造器初始化之后
    }
}
class User {
    String name;
    int age = 1;
    public User() {
        
    }
    public User(int age) {
        this.age = age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
```



```java
public class OrderTest {
    public static void main(String[] args) {
        Order order = new Order();
        System.out.println(order.orderId); // 输出3还是4取决于Order类中代码块和显式赋值的先后顺序，后声明的会覆盖先声明的
        // 一般都是先声明属性再声明代码块，所以一般是代码块后执行，但是这两个初始化是并列顺序。
    }
}
class Order {
    // 类中和方法体中执行顺序不同
    {
        orderId = 4;
    }
    int orderId = 3;
}
```

## 方法

方法 = 成员方法 = 函数 = method

### 方法的重载

1. 同一个类中，方法名相同，参数列表不同。（参数个数或类型或顺序不同）
2. 跟方法的权限修饰符、返回值类型、形参参数名、方法体无关。
3. 若找不到与传入参数匹配的方法则匹配自动类型提升的方法。

### 可变个数的形参

格式：

```java
public void show(String ... strs){
    for (int i = 0; i < strs.length; i++) {
        System.out.println(strs[i]);
    }
}
```

注意：

1. 调用可变个数形参的方法时，传入的参数个数可以是：**0个**、1个、2个。。。n个。
2. `public void show(String ... strs){}`与`public void show(String[] strs){}`不能共存。编译器认为是同一个方法。
3. 可变个数的形参只能声明在参数列表的末尾，故一个方法只能声明一个可变形参。

### 方法参数的值传递机制

1. 形参：方法定义时，声明在小括号内的参数。

   实参：方法调用时，实际传递给形参的数据。

2. 值传递机制：

   如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。

   如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。

> 值传递(pass by value) 是指在调用函数时将实际参数**复制**一份传递到函数中，这样在函数中如果对**参数**进行修改，不会影响到实际参数。
>
> 引用传递(pass by reference) 是指在调用函数时将实际参数的地址**直接**传递到函数中，那么在函数中对**参数**所进行的修改将影响到实际参数。

当我们在main中创建一个User对象的时候，在堆中开辟一块内存，其中保存了name和gender等数据。然后hollis持有该内存的地址，假设为`0x123456`。当尝试调用pass方法，并且hollis作为实际参数传递给形式参数user的时候，会把这个地址`0x123456`交给user，这时，user也指向了这个地址。然后在pass方法内对参数进行修改的时候，即`user = new User();`会重新开辟一块假设地址为`0X456789`的内存，赋值给user。后面对user的任何修改都不会改变内存`0x123456`的内容。

上面这种传递是什么传递？肯定不是引用传递，如果是引用传递的话，在`user = new User();`的时候，实际参数的引用也应该改为指向`0X456789`，但是实际上并没有。

通过概念我们也能知道，这里是把实际参数的引用的地址复制了一份，传递给了形式参数。所以，上面的参数其实是值传递，把实参对象引用的地址当做值传递给了形式参数。

Java引用和C/C++指针的最大区别在于，引用的地址必指向对象，因为都是先在堆中new再把地址传给栈中的引用变量。而指针的地址指向的是一块内存空间，不考虑这块内存里存放的内容。指针可以进行算术运算，而引用不可以。

```java
public static void main(String[] args) {
    ParamTest pt = new ParamTest();
    User hollis = new User();
    hollis.setName("Hollis");
    hollis.setGender("Male");
    pt.pass(hollis);
    System.out.println("print in main , user is " + hollis); // print in main , user is User{name='Hollis', gender='Male'}
}
public void pass(User user) {
    user = new User();
    user.setName("hollischuang");
    user.setGender("Male");
    System.out.println("print in pass , user is " + user); // print in pass , user is User{name='hollischuang', gender='Male'}
}
```

常见问题：

```java
int[] arr = {1, 2};
// 错误写法
swap(arr[0], arr[1]);
// 正确写法
swap(arr, 0, 1);
// 错误
public void swap(int i, int j){
    int temp = i;
    i = j;
    j = temp;
}
// 正确
public void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

面试题：

```java
// 面试题一
public class Test {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        method(a, b); // 需要在method方法被调用后，仅打印出a=100,b=200.请写出method方法的代码。
        System.out.println("a="+a);
        System.out.println("b="+b);
    }
    // 方法一
    public static void method(int a, int b) {
        a = a * 10;
        b = b * 20;
        System.out.println("a="+a);
        System.out.println("b="+b);
        System.exit(0); // 终止当前运行的Java虚拟机。 该参数作为状态代码; 按照惯例，非零状态码表示异常终止。
    }
    // 方法二
    public static void method(int a, int b) {
        PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x){
                if ("a=10".equals(x)) {
                    x = "a=100";
                }else if ("b=10".equals(x)) {
                    x = "b=200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
```

```java
// 面试题二
// 定义一个int型数组，让数组的每个位置上的值除以首位元素，得到的结果作为该位置上的新值。遍历新数组。
int[] arr = new int[]{12, 3, 3, 36, 48, 72, 432};
// 错误写法
for (int i = 0; i < arr.length; i++) {
    arr[i] = arr[i] / arr[0];
    System.out.print(arr[i]+"\t"); // 1  3  3  36  48  72  432
}
// 正确写法一
for (int i = arr.length - 1; i >= 0; i--) {
    arr[i] = arr[i] / arr[0];
    System.out.print(arr[i]+"\t"); // 1  0.25  0.25  3  4  6  36
}
// 正确写法二
int temp = arr[0];
for (int i = 0; i < arr.length; i++) {
    arr[i] = arr[i] / temp;
    System.out.print(arr[i]+"\t"); // 1  0.25  0.25  3  4  6  36
}
```

```java
// 面试题三
// 问控制台分别打印什么内容？
int[] arr1 = new int[]{1, 2, 3};
System.out.println(arr1); // [I@15db9742	地址值
char[] arr2 = new char[]{'a', 'b', 'c'};
System.out.println(arr2); // abc
// 原因：打印arr1调用的是java.io.PrintStream.println(Object x);打印arr2调用的是java.io.PrintStream.println(char[] x);
// 字符串的底层就是字符数组，所以打印字符数组会和打印字符串一样直接输出内容
```

### 递归方法

1. 递归方法：在一个方法的方法体内调用它本身。
2. 方法递归包含一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则会变成无穷递归，类似于死循环。

关于递归的常见问题：

```java
// 计算1到100之间所有自然数的和
public static void main(String[] args) {
    System.out.println(getSum(100));
}
public static int getSum(int n) {
    if (n == 1) {
        return 1;
    } else {
        return n + getSum(n - 1);
    }
}
```

```java
// 已知有一个数列：f(0) = 1, f(1) = 4, f(n+2) = 2 * f(n+1) + f(n),其中n是大于0的整数，求f(10)的值。
public static void main(String[] args) {
    System.out.println(f(10));
}
public static int f(int n) {
    if (n == 0) {
        return 1;
    } else if (n == 1) {
        return 4;
    } else {
        return 2 * f(n-1) + f(n-2);
        return f(n+2) - 2 * f(n+1); // 错误写法，已知值为f(0),f(1)，应该向这两个值靠近，而不是向f(n+2)和f(n+1)
    }
}
```

```java
// 斐波那契数列
// 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来。
// 1  1  2  3  5  8  13  21  34  55  .....
// 规律：从第三个数起任意一个数等于前两个数之和，f(n) = f(n-1) + f(n-2)
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    System.out.println("请输入想要获取斐波那契数列的第几个数：");
    int i = scanner.nextInt();
    System.out.println("斐波那契数列的第" + i + "个数为：" + f(i));
    for (int j = 1; j <= i; j++) {
        System.out.print(f(j) + "\t");
    }
}
public static int f(int n) {
    if (n == 1 || n == 2) {
        return 1;
    } else {
        return f(n-1) + f(n-2);
    }
}
// 爬楼梯问题实际上也是斐波那契数列问题
// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。
// 第n个台阶只能从第n-1或者n-2个上来。到第n-1个台阶的走法 + 第n-2个台阶的走法 = 到第n个台阶的走法，已经知道了第1个和第2个台阶的走法，一路加上去。
```

```java
// 汉诺塔问题
// 从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。
public class TowersOfHanoi {
    static int m = 0;//标记移动次数

    //实现移动的函数
    public static void move(int disks, char N, char M) {
        System.out.println("第" + (++m) + " 次移动 : " + " 把 " + disks + " 号圆盘从 " + N + " ->移到->  " + M);
    }

    //递归实现汉诺塔的函数
    public static void hanoi(int n, char A, char B, char C) {
        if (n == 1)//圆盘只有一个时，只需将其从A塔移到C塔
            TowersOfHanoi.move(1, A, C);//将编b号为1的圆盘从A移到C
        else {//否则
            hanoi(n - 1, A, C, B);//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔
            TowersOfHanoi.move(n, A, C);//把A塔上编号为n的圆盘移到C上
            hanoi(n - 1, B, A, C);//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔
        }
    }

    public static void main(String[] args) {
        Scanner imput = new Scanner(System.in);
        char A = 'A';
        char B = 'B';
        char C = 'C';
        System.out.println("******************************************************************************************");
        System.out.println("这是汉诺塔问题（把A塔上编号从小号到大号的圆盘从A塔通过B辅助塔移动到C塔上去");
        System.out.println("******************************************************************************************");
        System.out.print("请输入圆盘的个数：");
        int disks = imput.nextInt();
        TowersOfHanoi.hanoi(disks, A, B, C);
        System.out.println(">>移动了" + m + "次，把A上的圆盘都移动到了C上");
        imput.close();
    }
}
```

```java
// 快速排序
// 1.在数组中选一个基准数（通常为数组第一个）;
// 2.将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边;
// 3.对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。
private static void swap(int[] data, int i, int j) { // 定义一个方法用与交换数组下标为i和j的元素
    int temp = data[i];
    data[i] = data[j];
    data[j] = temp;
}
private static void subSort(int[] data, int start, int end) {
    if (start < end) {
        int base = data[start];
        int low = start;
        int high = end + 1;
        while (true) {
            while (low < end && data[++low] - base <= 0) {
            }
            while (high > start && data[--high] >= 0) {
            }
            if (low < high) {
                swap(data, low, high);
            } else {
                break;
            }
        }
        swap(data, start, high);
        subSort(data, start, high - 1);
        subSort(data, high + 1, end);
    }
}
public static void quickSort(int[] data) {
    subSort(data, 0, data.length - 1);
}
```

## 构造器（构造方法）

作用：1. 创建对象     2. 初始化对象的属性

定义构造器的格式：权限修饰符	类名（形参列表）{ }

构造器可以重载，一旦显式地定义了类的构造器，系统就不再提供默认的空参构造器。一个类中，至少会有一个构造器（人为定义或默认）。

默认构造器的权限和类权限相同。

## 代码块

代码块又叫初始化块，在类中用一对大括号包起来的结构就叫代码块。一个类中可以定义多个代码块（但没必要），按声明顺序执行。

1. 代码块的作用：用来初始化类、对象。

2. 代码块前如果要加修饰的话，只能加static。

3. 静态代码块 VS 非静态代码块：

   1. 静态代码块：

      ​	> 内部可以有打印输出等各种执行语句。

      ​	> 随着类的首次加载而执行，而且只执行一次。静态代码块先于非静态代码块执行。

      ​	> 可以初始化类中的静态成员，不能调用类的非静态成员。

   2. 非静态代码块：

      ​	> 内部可以有打印输出等各种执行语句。

      ​	> 随着对象的创建而执行，每创建一个对象，所有非静态代码块就执行一次。

      ​	> 可以在创建对象时，对对象的属性进行初始化。可以调用类的静态成员和非静态成员。

```java
// 代码块应用举例
public class JDBCUtils {
    private static DataSource dataSource = null;
    static {
        InputStream is = null;
        try {
            is = DBCPTest.class.getClassLoader().getResourceAsStream("dbcp.properties");
            Properties pros = new Properties();
            pros.load(is);
            dataSource = BasicDataSourceFactory.createDataSource(pros);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static Connection getConnection2() throws SQLException {
        Connection conn = dataSource.getConnection();
        return conn;
    }
}
```



```java
// 由父及子，静态先行
class Root {
    static {
        System.out.println("Root的静态初始化块");
    }
    {
        System.out.println("Root的普通初始化块");
    }
    public Root() {
        super();
        System.out.println("Root的无参数构造器");
    }
}
class Mid extends Root {
    static {
        System.out.println("Mid的静态初始化块");
    }
    {
        System.out.println("Mid的普通初始化块");
    }
    public Mid() {
        super();
        System.out.println("Mid的无参数构造器");
    }
    public Mid(String msg) {
        this();
        System.out.println("Mid的带参数构造器，其参数值：" + msg);
    }
}
class Leaf extends Mid {
    static {
        System.out.println("Leaf的静态初始化块");
    }
    {
        System.out.println("Leaf的普通初始化块");
    }
    public Leaf() {
        super("尚硅谷");
        System.out.println("Leaf的构造器");
    }
}
public class LeafTest {
    public static void main(String[] args) {
        new Leaf();
    }
}
// Root的静态初始化块
// Mid的静态初始化块
// Leaf的静态初始化块
// Root的普通初始化块
// Root的无参数构造器
// Mid的普通初始化块
// Mid的无参数构造器
// Mid的带参数构造器，其参数值：尚硅谷
// Leaf的普通初始化块
// Leaf的构造器
```



```java
// 静态代码块的加载先于main方法的执行
class Father {
    static {
        System.out.println("111111");
    }
    {
        System.out.println("222222");
    }
    public Father() {
        System.out.println("333333");
    }
}
public class Son extends Father {
    static {
        System.out.println("444444");
    }
    {
        System.out.println("555555");
    }
    public Son() {
        System.out.println("666666");
    }
    public static void main(String[] args) {
        System.out.println("777777");
        System.out.println("******");
        new Son();
    }
}
// 111111
// 444444
// 777777
// ******
// 222222
// 333333
// 555555
// 666666
```

## 内部类



# OOP主线二：面向对象三大特征

## 封装

**程序设计追求"高内聚、低耦合"**

> 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。
>
> 低耦合：仅对外暴露少量的方法用于使用。

### 封装性的设计思想

隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可拓展性、可维护性。通俗来说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。

### 封装性的体现

1. 将类的属性私有化，同时提供公共的方法获取和设置属性的值。
2. 不对外暴露的私有化方法。
3. 单例模式中构造器私有化。
4. .....

### 权限修饰符

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| (缺省)    | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |

若想跨工程调用，则必须拷贝代码或者导入jar包。

4种权限修饰符都可以用来修饰类的内部结构：属性、方法、构造器、内部类。**修饰类只能缺省或public**

### JavaBean

`JavaBean`是一种Java语言写成的可重用组件。

`JavaBean`是指符合以下标准的Java类：

> 类是公共的
>
> 有一个无参的公共的构造器
>
> 有属性，且有对应的get、set方法

## 继承

### 继承性的好处

① 减少了代码的冗余，提高了代码的复用性。

② 便于功能的拓展。

③ 为多态性的使用提供了前提。

### 继承的格式

class A extends B { }

A：子类、派生类、subclass

B：父类、超类、基类、superclass

一旦子类A继承父类B之后，子类A就获取了父类B中声明的所有属性和方法。**私有的结构也会继承只是不能直接访问**。

extends：延展、扩展。子类的功能一般都比父类更强大。

### Java中关于继承性的规定

1. 一个类可以被多个子类继承。
2. 单继承性：一个类只能有一个父类。
3. 子父类是相对的概念。可以有多层继承。C继承B，B继承A，称B是C的直接父类，A是C的间接父类。
4. 子类继承父类之后，就获取了直接父类和所有间接父类中声明的属性和方法。
5. 所有Java类（除`java.lang.Object`类之外）都直接或间接地继承于`java.lang.Object`类。

### 方法的重写（override / overwrite）

1. 定义：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。

2. 应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数方法时，实际执行的是子类重写父类的方法。

3. 规定：

   ​			方法的声明：  `权限修饰符`	`返回值类型`	`方法名`（`形参列表`）	`throws`	`异常的类型` {

   ​											// 方法体

   ​									}

   ​			约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法。

   ​	① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。

   ​	② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。

   ​			> 特殊情况：子类不能重写父类中声明为private权限的方法。

   ​	③ 返回值类型：

   ​			> 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void。

   ​			> 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类。

   ​			> 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型。

   ​	④ **子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型**。

   ​	⑤ **子类和父类中同名同参数的方法要么都声明为非static的（是重写），要么都声明为static的（不是重写）**。

   ```java
   public class Test {
       public static void main(String[] args) {
           /**
           * 结论：
           * 静态方法可以被继承，但是不能被覆盖，即不能重写。
           * */
           Son.staticMethod(); // 运行结果：Father staticMethod
       }
   }
   class Father {
       public static void staticMethod() {
           System.out.println("Father staticMethod");
       }
   }
   class Son extends Father {
   }
   ```

   ```java
   public class Test {
       public static void main(String[] args) {
           Father.staticMethod(); // 运行结果：Father staticMethod
           /**
            * 结论：
            * 类执行了自己申明的静态方法。
            * 该子类实际上只是将父类中的同名静态方法进行了隐藏，而非重写。
            * */
           Son.staticMethod(); // 运行结果：Son staticMethod
           Father father = new Son();
           /**
            * 结论：
            * 父类引用指向子类对象时，只会调用父类的静态方法。
            * 父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。
            * */
           father.staticMethod(); // 运行结果：Father staticMethod
       }
   }
   class Father {
       public static void staticMethod() {
           System.out.println("Father staticMethod");
       }
   }
   class Son extends Father {
       public static void staticMethod() {
           System.out.println("Son staticMethod");
       }
   }
   // 1. 在Java中静态方法可以被继承，但是不能被覆盖，即不能重写。
   // 2. 如果子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。
   // 3. 父类引用指向子类对象时，只会调用父类的静态方法。所以，它们的行为也并不具有多态性。
   // 4. 我们应该直接使用类名来访问静态方法，而不要使用对象引用来访问。
   ```

### 子类对象的实例化过程

1. 从结果上来看：子类继承父类以后，就获取了父类中声明的属性和方法。创建子类的对象，在堆空间中会加载所有父类中声明的属性和方法。

2. 从过程上来看：当通过子类的构造器创建子类对象时，一定会直接或间接地调用其父类的构造器，进而调用父类的父类的构造器，直到调用了`java.lang.Object`类中的空参构造器为止。正因为调用过所有父类的构造器，内存中才会有所有父类的结构，子类对象才可以调用父类结构。

   ps：虽然创建子类对象时，调用了父类的构造器，但是调用父类构造器时只是将父类结构加载到子类对象中，且并未暴露父类结构的地址，所以自始至终只`new`了一个对象。

## 多态

### 向上转型

对象的多态性是向上转型。

多态：同一个事物的多种形态。

什么是[对象的]多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）。

多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用。编译期只能调用父类中声明的方法，但运行期实际执行的是子类重写父类的方法。总结：编译看左边，运行看右边。**对象的多态性只适用于方法，不适用于属性**。

多态性的使用前提： ① 类的继承关系	② 方法的重写

```java
public class Test {
    public static void main() {
    	Person p1 = new Man(); // 父类的引用指向子类的对象
    	p1.eat(); // 男人：大口吃饭	（虚拟方法调用）
    	p1.earnMoney(); // 编译时报错，只能调用Person类中声明了的方法
	}
}
class Person {
    private String name;
    private int age;
    public void eat() {
        System.out.println("人：吃饭");
    }
}
class Man extends Person {
    private boolean isSmoking;
    public void eat() {
        System.out.println("男人：大口吃饭");
    }
    public void earnMoney() {
        System.out.println("男人：挣钱养家");
    }
}
```



```java
// 多态性的使用举例：
public class AnimalTest {
    public static void main(String[] args) {
        AnimalTest test = new AnimalTest();
        test.func(new Dog()); // 狗吃骨头汪汪汪
        test.func(new Dog()); // 猫吃鱼喵喵喵
    }
    public void func(Animal animal) {
        animal.eat();
        animal.shout();
    }
    // 如果没有多态性，只能重载func方法，有多少个子类就需要重载多少次fanc（多态的好处）
    public void func(Dog dog) {
        dog.eat();
        dog.shout();
    }
    public void func(Cat cat) {
        cat.eat();
        cat.shout();
    }
    ······
}
class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
    public void shout() {
        System.out.println("动物叫");
    }
}
class Dog {
    public void eat() {
        System.out.println("狗吃骨头");
    }
    public void shout() {
        System.out.println("汪汪汪");
    }
}
class Cat {
    public void eat() {
        System.out.println("猫吃鱼");
    }
    public void shout() {
        System.out.println("喵喵喵");
    }
}
```

**虚拟方法调用**：子类中重写了父类方法，在多态情况下（父类引用指向子类对象），将此时父类中被重写的方法称为虚拟方法，父类根据赋给它的不同子类对象，在运行时动态调用属于子类的重写方法。这种方法调用在编译期是无法确定的。

**动态绑定**：编译时对象的类型为接收它的引用的类型，而方法的调用是在运行时确定的。

```java
// 面试题：多态是编译时行为还是运行时行为? 如何证明？
public class InterviewTest {
    public static Animal getInstance(int key) {
        switch(key) {
            case 0 :
                return new Cat();
            case 1 :
                return new Dog();
            default:
                return new Sheep();
        }
    }
    public static void main(String[] args) {
        int key = new Random().nextInt(3);
        System.out.println(key);
        Animal animal = getInstance(key);
        animal.eat();
        // 多态是运行时行为，因为只有程序运行后才能确定调用的是哪个子类的eat方法
    }
}
class Animal {
    protected void eat() {
        System.out.println("animal eat food");
    }
}
class Cat extends Animal {
    protected void eat() {
        System.out.println("cat eat fish");
    }
}
class Dog extends Animal {
    protected void eat() {
        System.out.println("dog eat bone");
    }
}
class Sheep extends Animal {
    protected void eat() {
        System.out.println("sheep eat grass");
    }
}
```

小结：方法的重载和重写

1. 二者的定义细节

2. 从编译和运行的角度看：

   ​		重载，是指允许存在多个同名方法，而这些方法的参数列表不同。编译器根据方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法实际上是不同的方法，**它们的调用地址在编译期就绑定了**。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了将要调用的方法，这称为`早绑定`或`静态绑定`。

   ​		重写，子类中重写了父类方法，在多态情况下（父类引用指向子类对象），将此时父类中被重写的方法称为虚拟方法，父类根据赋给它的不同子类对象，在运行时动态调用属于子类的重写方法。**这种方法调用在编译期是无法确定的**。只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为`晚绑定`或`动态绑定`。

   `不要犯傻，如果它不是晚绑定，它就不是多态。		-- Bruce Eckel`	所以重载并不是多态。

### 向下转型

有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。

实际new的是子类对象，用父类类型接收的情况才可以向下转型。如果实际new的就是父类对象，则不存在向下转型。

```java
public class Test {
    public static void main() {
    	Person p1 = new Man(); // 父类的引用指向子类的对象
    	p1.eat(); // 男人：大口吃饭	（虚拟方法调用）
    	p1.earnMoney(); // 编译时报错，只能调用Person类中声明了的方法
        Man m1 = (Man)p1; // 向下转型：使用强制类型转换。
        m1.earnMoney();
        // 强转时，可能出现ClassCastException
        Woman w1 = (Woman)p1; // 运行时异常
        w1.goShopping();
	}
}
class Person {
    private String name;
    private int age;
    public void eat() {
        System.out.println("人：吃饭");
    }
}
class Man extends Person {
    private boolean isSmoking;
    public void eat() {
        System.out.println("男人：大口吃饭");
    }
    public void earnMoney() {
        System.out.println("男人：挣钱养家");
    }
}
class Woman extends Person {
    private boolean isBeauty;
    public void eat() {
        System.out.println("女人：小口吃饭");
    }
    public void goShopping() {
        System.out.println("女人：购物");
    }
}
```

# OOP主线三：关键字

## return

使用范围：方法体中

作用：①结束方法，`return；`

​		   ②结束方法并返回数据，`return 数据；`

return关键字后不可有执行语句。

## this

1. this可以用来修饰或调用：属性、方法、构造器。
2. `this.属性`或`this.方法`时，this理解为"当前对象" 或 "当前正在创建的对象"(构造器中)。
3. this调用构造器，`this();`表示调用无参构造器，`this(参数类型 参数名);`表示调用有参构造器。**只能调用其他构造器，不能形成递归调用（闭环）**。所以：一个类有n个构造器，最多有n-1个构造器调用`this(形参列表);`
4. `this(形参列表);`必须声明在第一行，所以一个构造器只能使用一次`this(形参列表)`;
5. 使用`this`时，先去当前对象的类里面找，**找不到再去当前对象的父类找**。

## super

1. 需要用到`super`的情况：

   ​	① 子类中有与父类同名的属性（属性不存在重写和覆盖，两个属性都会存在于子类中），指定父类的属性可以用`super.属性`。

   ​	② 子类重写了父类方法，指定父类的方法可以用`super.方法`。

   ​	③ `super(形参列表);`表示调用父类的构造器。

2. 使用`super`时，先去直接父类找，找不到再去间接父类。

3. 调用父类中的非重名属性或方法，使用`this`或缺省都可以。

4. `super(形参列表);`必须声明在子类构造器的首行，与`this(形参列表);`冲突，只能二选一。

5. 构造器中`super(形参列表);`和`this(形参列表);`都没有显式声明的情况下，编译器默认调用`super();`。

6. 一个类有n个构造器，最多有n-1个构造器调用`this(形参列表);`最少有1个构造器调用`super(形参列表);`即一个类总会直接或间接地调用`super(形参列表);`

## instanceof

`a  instanceof A`	判断对象a是否是类A的一个实例。如果是，返回true；如果不是，返回false。

如果`a  instanceof A`返回true，则`a  instanceof B`也返回true，其中类B是类A的父类。

使用情境：为了避免在向下转型时出现`ClassCastException`异常。

```java
// 多态面试题
public class InterviewTest {
    public static void main(String[] args) {
        Base base = new Sub();
        base.add(1, 2, 3); // sub1	编译器认为int ... arr 和 int[] arr 是相同的参数，所以构成重写，满足多态性。
        
        Sub s = (Sub)base;
        s.add(1, 2, 3); // sub2		向下转型后只会调用Sub中的方法，确定参数和可变参数方法重载优先调用确定参数的方法。
    }
}
class Base {
    public void add(int a, int ... arr) {
        System.out.println("base1");
    }
}
class Sub extends Base {
    public void add(int a, int[] arr) {
        System.out.println("sub1");
    }
    public void add(int a, int b, int c) {
        System.out.println("sub2");
    }
}
```

## static

static：静态的。可以用来修饰：属性、方法、代码块、内部类。

### 用法

1. static修饰属性：静态变量（类变量）

   1. 属性按是否被static修饰，又分为：静态属性（类变量）、非静态属性（实例变量）。

      ​	实例变量：创建类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象的非静态属性时，不影响其他对象的同名属性。

      ​	静态变量：创建类的多个对象，多个对象共享一个静态变量。通过某一个对象修改静态变量时，所有对象的静态变量都会随之改变。

   2. static修饰属性的其他说明：

      ​	① 静态变量随类的加载而加载。通过`类.静态变量`的方式进行调用。

      ​	② 静态变量的加载要早于对象的创建。

      ​	③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

      ​	④ 可以通过`类名.静态变量`、`对象.静态变量`、`对象.实例变量`进行调用。不可以通过`类名.实例变量`调用，会编译报错。静态变量一般都通过类名调用。

   3. 静态变量举例：`System.out`、`Math.PI`

2. static修饰方法：静态方法

   ​	① 静态方法随类的加载而加载，可以通过`类名.静态方法`的方式进行调用。

   ​	② 可以通过`类名.静态方法`、`对象.实例方法`、`对象.实例方法`进行调用。不能通过`类名.实例方法`调用，编译报错。一般用法：`类名.静态方法`。

   ​	③ 静态方法中，只能调用静态的方法或属性。非静态方法中，既可以调用非静态的方法和属性，也可以调用静态的方法和属性。

3. static修饰代码块：

4. static修饰内部类：

### 注意点

1. 静态方法内不能使用`this`和`super`关键字。

2. 关于静态方法和静态属性的使用，都从生命周期的角度去理解。

3. 如何确定属性和方法是否要声明为static的？

   ​	> 属性是可以被多个对象共享的，不会随对象不同而不同的。

   ​	> 类中的常量一般都声明为static的，节省空间。

   ​	> 操作静态属性的方法通常也声明为static的。

   ​	> 工具类中的方法，习惯上声明为static的，可以通过`类名.方法`方便调用。如：`Math`、`Arrays`、`Collections`。

### 单例（Singleton）设计模式

#### 定义

所谓的单例设计模式，就是采取一定的方法保证在整个软件系统中，对**某个类只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。

举例：`java.lang.Runtime`类就是单例模式。

#### 实现

1. 将构造器的访问权限设置为`private`，确保类的外部无法创建实例。
2. 在类的内部创建一个该类的静态实例。
3. 声明一个静态方法，返回上一步中创建的静态实例。

#### 饿汉式 VS 懒汉式

```java
// 饿汉式单例模式
class Bank {
    // 1.私有化构造器
    private Bank(){};
    // 2.类内部创建类的对象
    // 4.此对象也必须声明为静态的
    private static Bank instance = new Bank();
    // 3.提供公共的静态方法，返回类的对象
    public static Bank getInstance() {
        return instance;
    }
}
```

```java
// 线程不安全的懒汉式单例模式
class Bank {
    // 1.私有化构造器
    private Bank(){};
    // 2.声明当前类对象而不初始化
    // 4.此对象也必须声明为静态的
    private static Bank instance = null;
    // 3.提供公共的静态方法，初次调用时初始化类的对象并返回
    public static Bank getInstance() {
        if (instance == null) {
            instance = new Bank(); // 此处线程不安全，有可能多个线程new多个实例，就不再是单例模式
        }
        return instance;
    }
}
```

```java
// 线程安全的懒汉式单例模式
class Bank {
    // 1.私有化构造器
    private Bank(){};
    // 2.声明当前类对象而不初始化
    // 4.此对象也必须声明为静态的
    private static Bank instance = null;
    // 3.提供公共的静态方法，初次调用时初始化类的对象并返回
    public synchronized static Bank getInstance() {
        if (instance == null) {
            instance = new Bank(); // 此处线程不安全，有可能多个线程new多个实例，就不再是单例模式
        }
        return instance;
    }
}
// 直接加锁效率不高，改进版

```

饿汉式是线程安全的，但是对象加载时间过长，内存开销更大。

懒汉式延迟了对象的创建，减少了内存开销，但是针对多线程环境需要优化代码。

#### 应用场景

由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

- **网站的计数器**，一般都是单例模式实现，否则难以同步。
- **应用程序的日志应用**，一般都使用单例模式实现，这是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则不好追加内容。
- **数据库连接池**的设计一般也是采取单例模式，因为数据库连接是一种数据库资源。
- 项目中，**读取配置文件的类**，一般也只有一个对象。没有必要每次使用配置文件数据都生成一个对象去读取。
- **Application也是典型的单例应用**。
- Windows的**Task Manager（任务管理器）**就是很典型的单例模式。
- Windows的**Recycle Bin（回收站）**也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

## final

final：最终的

final可以用来修饰的结构：类、方法、变量。

1. final修饰类：此类不能被其他类继承。如：`String`类、`System`类、`StringBuffer`类。

2. final修饰方法：此方法不能被重写。如：`Object`类中的`getClass()`方法。

3. final修饰变量：变量初始化后不能再修改变量的值。实际上是一个常量。

   1. final修饰属性：可以初始化赋值的位置：显式初始化（每个对象值相同）、代码块中初始化（赋值需要进行复杂操作）、构造器中初始化（每个对象值不同）。即必须在对象创建之前完成初始化

   2. final修饰局部变量：

      ​	① 方法内定义的局部变量，初始化后值不可变。可以`final int i = 10;`也可以先声明后赋值`final int i;    i = 10;`声明后只能赋一次值。

      ​	② 形参，`public void show(final int num){}`，形参被final修饰的方法方法体内不能对形参进行修改，只能是调用方法时传进来的值。

`static final`同时使用，可以修饰属性和方法。修饰属性：全局常量（接口中的属性只能是全局常量）。修饰方法：静态不能被重写。自定义方法一般都不加final

## abstract



## interface



# 补充

## 面向对象和面向过程的区别

1. 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。
2. 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

属性 = 成员变量 = field = 域、字段

方法 = 成员方法 = 函数 = method

创建类的对象 = 类的实例化 = 实例化类

## 万事万物皆对象

1. 在Java语言的范畴内，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。

   ​	> Scanner，String等

   ​	> 文件：File

   ​	> 网络资源：URL

2. 涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时都体现为类、对象。

## 理解main方法的语法

1. `main()`方法作为程序的入口，方法名只能是`main`。

2. `main()`方法也是一个普通的静态方法，静态方法中只能直接调用静态方法或静态变量。

3. `main()`方法只能声明为`public`，这样`Java虚拟机`才能找到这个入口。

4. `main()`方法的形参`String[] args`使得我们可以通过`main()`方法与控制台进行交互。之前都是使用`Scanner`类。

   ​	① 使用`Eclipse`的`Run Configurations`，左边找到对应的class文件，右边`Arguments`下的`Program arguments`输入传给`args`的值，空格隔开。

   ​	② 命令行，`javac`编译之后，`java 类名 参数`，参数仍然用空格隔开。